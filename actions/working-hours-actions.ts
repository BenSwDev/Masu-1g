"use server"

import { getServerSession } from "next-auth"
import { revalidatePath } from "next/cache"
import { authOptions } from "@/lib/auth/auth"
import { dbConnect } from "@/lib/db/mongoose"
import {
  WorkingHours,
  type IWorkingHours,
  type ISpecialDate,
  type IWeeklyHoursDay,
} from "@/lib/db/models/working-hours" // Ensure IWeeklyHoursDay is exported
import { UserRole } from "@/lib/db/models/user"
import { logger } from "@/lib/logs/logger"

interface ActionResult<T = any> {
  success: boolean
  data?: T
  error?: string
  isActive?: boolean // Specifically for toggleSpecialDateStatus
}

/**
 * Fetches all working hours and special dates.
 * @returns {Promise<ActionResult<IWorkingHours>>} The working hours data or an error message.
 */
export async function getWorkingHours(): Promise<ActionResult<IWorkingHours>> {
  try {
    await dbConnect()
    logger.info("Fetching working hours from database.")

    let workingHoursDoc = await WorkingHours.findOne().lean<IWorkingHours>()

    if (!workingHoursDoc) {
      logger.warn("No working hours document found, creating and returning default structure.")
      const defaultData: Omit<IWorkingHours, "_id"> = {
        // _id will be generated by MongoDB
        weeklyHours: [
          {
            dayOfWeek: 0,
            isActive: false,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 1,
            isActive: true,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 2,
            isActive: true,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 3,
            isActive: true,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 4,
            isActive: true,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 5,
            isActive: true,
            startTime: "09:00",
            endTime: "14:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
          {
            dayOfWeek: 6,
            isActive: false,
            startTime: "09:00",
            endTime: "17:00",
            priceAdjustment: { type: "none", value: 0, reason: "" },
          },
        ],
        specialDates: [],
      }
      const newWorkingHours = new WorkingHours(defaultData)
      workingHoursDoc = (await newWorkingHours.save()) as IWorkingHours // Save and cast
      workingHoursDoc = JSON.parse(JSON.stringify(workingHoursDoc)) // Re-serialize after save to ensure lean-like object
    }

    // Serialize the data, ensuring _id is a string and dates are formatted
    const serializedData: IWorkingHours = {
      ...workingHoursDoc,
      _id: workingHoursDoc._id.toString(),
      weeklyHours: workingHoursDoc.weeklyHours.map((wh: IWeeklyHoursDay) => ({
        // Added type for wh
        ...wh,
      })),
      specialDates: workingHoursDoc.specialDates.map((sd: ISpecialDate) => ({
        // Added type for sd
        ...sd,
        _id: sd._id.toString(),
        date: new Date(sd.date).toISOString().split("T")[0],
      })),
    }

    logger.info("Successfully fetched and serialized working hours.")
    return { success: true, data: serializedData }
  } catch (error) {
    logger.error("Error fetching working hours:", { error })
    const errorMessage = error instanceof Error ? error.message : "Failed to fetch working hours"
    return { success: false, error: errorMessage }
  }
}

/**
 * Updates the weekly working hours.
 * Requires admin privileges.
 * @param {IWeeklyHoursDay[]} weeklyHours - The array of weekly hours to set.
 * @returns {Promise<ActionResult<IWorkingHours>>} The updated working hours document or an error message.
 */
export async function updateWeeklyHours(weeklyHours: IWeeklyHoursDay[]): Promise<ActionResult<IWorkingHours>> {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.roles?.includes(UserRole.ADMIN)) {
      logger.warn("Unauthorized attempt to update weekly hours.", { userId: session?.user?._id })
      return { success: false, error: "Unauthorized" }
    }

    await dbConnect()
    logger.info("Updating weekly hours.", { userId: session.user._id })

    const updatedWorkingHours = await WorkingHours.findOneAndUpdate(
      {},
      { $set: { weeklyHours: weeklyHours } },
      { upsert: true, new: true, lean: true },
    )

    if (!updatedWorkingHours) {
      logger.error("Failed to update weekly hours, findOneAndUpdate returned null.")
      return { success: false, error: "Failed to update weekly hours" }
    }

    revalidatePath("/dashboard/admin/working-hours")
    logger.info("Successfully updated weekly hours.")
    return { success: true, data: JSON.parse(JSON.stringify(updatedWorkingHours)) }
  } catch (error) {
    logger.error("Error updating weekly hours:", { error })
    const errorMessage = error instanceof Error ? error.message : "Failed to update weekly hours"
    return { success: false, error: errorMessage }
  }
}

/**
 * Adds a new special date.
 * Requires admin privileges.
 * @param {Omit<ISpecialDate, "_id">} specialDateData - The special date data to add.
 * @returns {Promise<ActionResult<IWorkingHours>>} The updated working hours document or an error message.
 */
export async function addSpecialDate(specialDateData: Omit<ISpecialDate, "_id">): Promise<ActionResult<IWorkingHours>> {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.roles?.includes(UserRole.ADMIN)) {
      logger.warn("Unauthorized attempt to add special date.", { userId: session?.user?._id })
      return { success: false, error: "Unauthorized" }
    }

    await dbConnect()
    logger.info("Adding special date.", { userId: session.user._id, data: specialDateData })

    const dataToSave = {
      ...specialDateData,
      date: new Date(specialDateData.date), // Ensure date is stored as Date object
      startTime: specialDateData.startTime || null,
      endTime: specialDateData.endTime || null,
      priceAdjustment: specialDateData.priceAdjustment || { type: "none", value: 0, reason: "" },
    }

    const workingHours = await WorkingHours.findOneAndUpdate(
      {},
      { $push: { specialDates: dataToSave as any } }, // Cast to any if subdocument type mismatch
      { upsert: true, new: true, lean: true },
    )

    if (!workingHours) {
      logger.error("Failed to add special date, findOneAndUpdate returned null.")
      return { success: false, error: "Failed to add special date" }
    }

    revalidatePath("/dashboard/admin/working-hours")
    logger.info("Successfully added special date.")
    return { success: true, data: JSON.parse(JSON.stringify(workingHours)) }
  } catch (error) {
    logger.error("Error adding special date:", { error })
    const errorMessage = error instanceof Error ? error.message : "Failed to add special date"
    return { success: false, error: errorMessage }
  }
}

/**
 * Updates an existing special date.
 * Requires admin privileges.
 * @param {string} dateId - The ID of the special date to update.
 * @param {Partial<Omit<ISpecialDate, "_id">>} specialDateUpdateData - The data to update for the special date.
 * @returns {Promise<ActionResult<IWorkingHours>>} The updated working hours document or an error message.
 */
export async function updateSpecialDate(
  dateId: string,
  specialDateUpdateData: Partial<Omit<ISpecialDate, "_id">>,
): Promise<ActionResult<IWorkingHours>> {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.roles?.includes(UserRole.ADMIN)) {
      logger.warn("Unauthorized attempt to update special date.", { userId: session?.user?._id, dateId })
      return { success: false, error: "Unauthorized" }
    }

    await dbConnect()
    logger.info("Updating special date.", { userId: session.user._id, dateId, data: specialDateUpdateData })

    const setOperation: Record<string, any> = {}
    for (const key in specialDateUpdateData) {
      if (Object.prototype.hasOwnProperty.call(specialDateUpdateData, key)) {
        // @ts-ignore
        const value = specialDateUpdateData[key]
        if (key === "date" && typeof value === "string") {
          setOperation[`specialDates.$.${key}`] = new Date(value)
        } else if (key === "startTime" || key === "endTime") {
          setOperation[`specialDates.$.${key}`] = value || null
        } else {
          setOperation[`specialDates.$.${key}`] = value
        }
      }
    }
    // Ensure priceAdjustment is fully set or unset
    if ("priceAdjustment" in specialDateUpdateData) {
      setOperation["specialDates.$.priceAdjustment"] = specialDateUpdateData.priceAdjustment || {
        type: "none",
        value: 0,
        reason: "",
      }
    }

    const workingHours = await WorkingHours.findOneAndUpdate(
      { "specialDates._id": dateId },
      { $set: setOperation },
      { new: true, lean: true },
    )

    if (!workingHours) {
      logger.error("Failed to update special date, findOneAndUpdate returned null or dateId not found.", { dateId })
      return { success: false, error: "Special date not found or failed to update" }
    }

    revalidatePath("/dashboard/admin/working-hours")
    logger.info("Successfully updated special date.", { dateId })
    return { success: true, data: JSON.parse(JSON.stringify(workingHours)) }
  } catch (error) {
    logger.error("Error updating special date:", { error, dateId })
    const errorMessage = error instanceof Error ? error.message : "Failed to update special date"
    return { success: false, error: errorMessage }
  }
}

/**
 * Deletes a special date.
 * Requires admin privileges.
 * @param {string} dateId - The ID of the special date to delete.
 * @returns {Promise<ActionResult<IWorkingHours>>} The updated working hours document or an error message.
 */
export async function deleteSpecialDate(dateId: string): Promise<ActionResult<IWorkingHours>> {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.roles?.includes(UserRole.ADMIN)) {
      logger.warn("Unauthorized attempt to delete special date.", { userId: session?.user?._id, dateId })
      return { success: false, error: "Unauthorized" }
    }

    await dbConnect()
    logger.info("Deleting special date.", { userId: session.user._id, dateId })

    const workingHours = await WorkingHours.findOneAndUpdate(
      {},
      { $pull: { specialDates: { _id: dateId } } },
      { new: true, lean: true },
    )

    revalidatePath("/dashboard/admin/working-hours")
    logger.info("Successfully deleted special date (or it was already deleted).", { dateId })

    const currentWorkingHours = await WorkingHours.findOne().lean<IWorkingHours>() // Fetch fresh state
    if (!currentWorkingHours) {
      // Handle case where the main document might have been deleted (unlikely)
      logger.warn("Working hours document not found after delete operation.")
      return { success: true, data: undefined } // Or a default structure
    }
    return { success: true, data: JSON.parse(JSON.stringify(currentWorkingHours)) }
  } catch (error) {
    logger.error("Error deleting special date:", { error, dateId })
    const errorMessage = error instanceof Error ? error.message : "Failed to delete special date"
    return { success: false, error: errorMessage }
  }
}

/**
 * Toggles the isActive status of a special date.
 * Requires admin privileges.
 * @param {string} dateId - The ID of the special date to toggle.
 * @returns {Promise<ActionResult<{ isActive: boolean }>>} The new isActive status or an error message.
 */
export async function toggleSpecialDateStatus(dateId: string): Promise<ActionResult<{ isActive: boolean }>> {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.roles?.includes(UserRole.ADMIN)) {
      logger.warn("Unauthorized attempt to toggle special date status.", { userId: session?.user?._id, dateId })
      return { success: false, error: "Unauthorized" }
    }

    await dbConnect()
    logger.info("Toggling special date status.", { userId: session.user._id, dateId })

    const currentWorkingHoursDoc = await WorkingHours.findOne({ "specialDates._id": dateId })
    if (!currentWorkingHoursDoc) {
      logger.error("Special date not found for toggling status.", { dateId })
      return { success: false, error: "Special date not found" }
    }

    const specialDate = currentWorkingHoursDoc.specialDates.find((date) => date._id.toString() === dateId)
    if (!specialDate) {
      logger.error("Special date subdocument not found after finding parent.", { dateId })
      return { success: false, error: "Special date not found" }
    }

    const newIsActive = !specialDate.isActive

    const updatedWorkingHours = await WorkingHours.findOneAndUpdate(
      { "specialDates._id": dateId },
      { $set: { "specialDates.$.isActive": newIsActive } },
      { new: true, lean: true },
    )

    if (!updatedWorkingHours) {
      logger.error("Failed to toggle special date status, findOneAndUpdate returned null.", { dateId })
      return { success: false, error: "Failed to toggle special date status" }
    }

    revalidatePath("/dashboard/admin/working-hours")
    logger.info("Successfully toggled special date status.", { dateId, newIsActive })
    return { success: true, data: JSON.parse(JSON.stringify(updatedWorkingHours)), isActive: newIsActive }
  } catch (error) {
    logger.error("Error toggling special date status:", { error, dateId })
    const errorMessage = error instanceof Error ? error.message : "Failed to toggle special date status"
    return { success: false, error: errorMessage }
  }
}
