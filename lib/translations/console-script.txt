// ×¡×§×¨×™×¤×˜ ×œ× ×™×ª×•×— ×ª×¨×’×•××™× ×—×¡×¨×™× - ××•×ª×× ×œ××¢×¨×›×ª i18n ×©×œ ×××¡×•
(function() {
    console.log('ğŸ” ××ª×—×™×œ × ×™×ª×•×— ×ª×¨×’×•××™× ×—×¡×¨×™× ×‘××¢×¨×›×ª ×××¡×•...');
    
    const missingTranslations = [];
    const foundTranslations = [];
    const hardcodedTexts = [];
    
    // ×‘×“×•×§ ×× ×™×© ×’×™×©×” ×œ×¤×•× ×§×¦×™×™×ª getMissingTranslations
    if (typeof window.getMissingTranslations === 'function') {
        console.log('ğŸ“‹ ××¤×¢×™×œ ×¤×•× ×§×¦×™×™×ª getMissingTranslations...');
        window.getMissingTranslations();
    }
    
    // ××¦× ××ª ×›×œ ×”×˜×§×¡×˜×™× ×”×§×©×™×—×™× ×‘×¢××•×“
    function findHardcodedTexts() {
        const walker = document.createTreeWalker(
            document.body,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        const textNodes = [];
        let node;
        
        while (node = walker.nextNode()) {
            const text = node.textContent.trim();
            if (text && text.length > 1) {
                textNodes.push({
                    text: text,
                    element: node.parentElement
                });
            }
        }
        
        return textNodes;
    }
    
    // ×‘×“×•×§ ×× ×˜×§×¡×˜ ×”×•× ×¢×‘×¨×™×ª
    function isHebrew(text) {
        const hebrewRegex = /[\u0590-\u05FF]/;
        return hebrewRegex.test(text);
    }
    
    // ×‘×“×•×§ ×× ×˜×§×¡×˜ ×”×•× ×× ×’×œ×™×ª ××©××¢×•×ª×™×ª
    function isEnglishText(text) {
        const englishRegex = /^[a-zA-Z\s\-_.,!?:()]+$/;
        return englishRegex.test(text) && text.length > 2;
    }
    
    // ×‘×“×•×§ ×× ×”××œ×× ×˜ ×”×•× ×›×¤×ª×•×¨ ××• ×ª×•×•×™×ª
    function isInteractiveElement(element) {
        const tagName = element.tagName.toLowerCase();
        const interactiveTags = ['button', 'a', 'label', 'span', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'td', 'th'];
        return interactiveTags.includes(tagName);
    }
    
    // ×‘×“×•×§ ×× ×˜×§×¡×˜ × ×¨××” ×›××• key ×©×œ ×ª×¨×’×•×
    function looksLikeTranslationKey(text) {
        // ××—×¤×© ×“×¤×•×¡×™× ×›××•: "common.save", "admin.treatments.title"
        return /^[a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z][a-zA-Z0-9_]*)+$/.test(text);
    }
    
    // ×‘×“×•×§ ×× ×”×˜×§×¡×˜ × ×¨××” ×›××• ×ª×¨×’×•× ×©× ×›×©×œ
    function isFailedTranslation(text) {
        return looksLikeTranslationKey(text);
    }
    
    // ×‘×“×•×§ ×× ×”××œ×× ×˜ ××›×™×œ React component attributes
    function hasReactAttributes(element) {
        const attributes = element.attributes;
        for (let i = 0; i < attributes.length; i++) {
            const attr = attributes[i];
            if (attr.name.startsWith('data-react') || 
                attr.name.startsWith('data-testid') ||
                element.closest('[data-react-root]')) {
                return true;
            }
        }
        return false;
    }
    
    // ×™×¦×™×¨×ª XPath ×œ××œ×× ×˜
    function getXPath(element) {
        if (element.id) return `//*[@id="${element.id}"]`;
        if (element === document.body) return '/html/body';
        
        let ix = 0;
        const siblings = element.parentNode.childNodes;
        for (let i = 0; i < siblings.length; i++) {
            const sibling = siblings[i];
            if (sibling === element) {
                return getXPath(element.parentNode) + '/' + element.tagName.toLowerCase() + '[' + (ix + 1) + ']';
            }
            if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {
                ix++;
            }
        }
    }
    
    // × ×ª×— ××ª ×›×œ ×”×˜×§×¡×˜×™×
    const textNodes = findHardcodedTexts();
    
    textNodes.forEach(({ text, element }) => {
        // ×“×œ×’ ×¢×œ ×˜×§×¡×˜×™× ×œ× ×¨×œ×•×•× ×˜×™×™×
        if (text.length < 2 || 
            /^\d+$/.test(text) || // ××¡×¤×¨×™× ×‘×œ×‘×“
            /^[^\w\u0590-\u05FF]+$/.test(text) || // ×¡×™×× ×™× ×‘×œ×‘×“
            text.includes('Â©') || 
            text.includes('Â®') ||
            text.includes('â‚ª') ||
            element.tagName === 'SCRIPT' ||
            element.tagName === 'STYLE' ||
            element.tagName === 'NOSCRIPT') {
            return;
        }
        
        const isHeb = isHebrew(text);
        const isEng = isEnglishText(text);
        const isInteractive = isInteractiveElement(element);
        const isFailedTrans = isFailedTranslation(text);
        const hasReact = hasReactAttributes(element);
        
        if (isFailedTrans) {
            // ×–×” × ×¨××” ×›××• key ×©×œ ×ª×¨×’×•× ×©× ×›×©×œ
            missingTranslations.push({
                text: text,
                element: element.tagName,
                className: element.className,
                id: element.id,
                type: 'Failed Translation Key',
                language: 'Key',
                xpath: getXPath(element),
                priority: 'HIGH'
            });
        } else if ((isHeb || isEng) && isInteractive) {
            // ×–×” × ×¨××” ×›××• ×˜×§×¡×˜ ×§×©×™×— ×©×¦×¨×™×š ×ª×¨×’×•×
            hardcodedTexts.push({
                text: text,
                element: element.tagName,
                className: element.className,
                id: element.id,
                type: 'Hardcoded Text',
                language: isHeb ? 'Hebrew' : 'English',
                xpath: getXPath(element),
                priority: hasReact ? 'HIGH' : 'MEDIUM'
            });
        }
    });
    
    // ×‘×“×•×§ ××ª localStorage ×¢×‘×•×¨ missing keys
    let storedMissingKeys = [];
    try {
        const language = localStorage.getItem('masu_language') || 'he';
        console.log(`ğŸŒ ×©×¤×” × ×•×›×—×™×ª: ${language}`);
        
        // × ×¡×” ×œ×’×©×ª ×œ××¢×¨×›×ª ×”×ª×¨×’×•××™×
        if (window.getMissingTranslations) {
            console.log('ğŸ“ ××¤×¢×™×œ getMissingTranslations...');
            window.getMissingTranslations();
        }
    } catch (e) {
        console.log('âš ï¸ ×œ× × ×™×ª×Ÿ ×œ×’×©×ª ×œ-localStorage ××• ×œ××¢×¨×›×ª ×”×ª×¨×’×•××™×');
    }
    
    // ×‘×“×•×§ ×¢×‘×•×¨ React DevTools
    const reactVersion = window.React ? window.React.version : 'Not found';
    console.log(`âš›ï¸ React version: ${reactVersion}`);
    
    // ×”×¦×’ ×ª×•×¦××•×ª
    console.log('\nğŸ“Š ×ª×•×¦××•×ª ×”× ×™×ª×•×—:');
    console.log('==================');
    
    if (missingTranslations.length > 0) {
        console.log(`\nğŸ”´ × ××¦××• ${missingTranslations.length} ×ª×¨×’×•××™× ×©× ×›×©×œ×• (keys ×©××•×¦×’×™× ×‘××§×•× ×”×ª×¨×’×•×):`);
        console.table(missingTranslations);
        
        const failedKeys = missingTranslations.map(item => `"${item.text}": ""`).join(',\n');
        console.log('\nğŸ“‹ Keys ×©× ×›×©×œ×• - ×œ×”×•×¡×¤×” ×œ×§×•×‘×¥ ×ª×¨×’×•××™×:');
        console.log('===========================================');
        console.log(`{\n${failedKeys}\n}`);
    }
    
    if (hardcodedTexts.length > 0) {
        console.log(`\nğŸŸ¡ × ××¦××• ${hardcodedTexts.length} ×˜×§×¡×˜×™× ×§×©×™×—×™× ×©×¦×¨×™×›×™× ×ª×¨×’×•×:`);
        console.table(hardcodedTexts);
        
        // ×™×¦×™×¨×ª ×”×¦×¢×•×ª ×œkeys
        const suggestedKeys = hardcodedTexts.map(item => {
            const cleanText = item.text.replace(/[^\w\u0590-\u05FF\s]/g, '').trim();
            const keyName = cleanText.toLowerCase()
                .replace(/\s+/g, '_')
                .replace(/[^\w\u0590-\u05FF_]/g, '')
                .substring(0, 50);
            
            return `"${keyName}": "${item.text}"`;
        }).join(',\n');
        
        console.log('\nğŸ“‹ ×”×¦×¢×•×ª ×œkeys ×—×“×©×™×:');
        console.log('========================');
        console.log(`{\n${suggestedKeys}\n}`);
    }
    
    if (missingTranslations.length === 0 && hardcodedTexts.length === 0) {
        console.log('\nâœ… ×œ× × ××¦××• ×‘×¢×™×•×ª ×ª×¨×’×•×!');
    }
    
    // ×©××™×¨×” ×‘×–×™×›×¨×•×Ÿ
    window.masuTranslationAnalysis = {
        failed: missingTranslations,
        hardcoded: hardcodedTexts,
        failedKeysJson: missingTranslations.length > 0 ? 
            `{\n${missingTranslations.map(item => `"${item.text}": ""`).join(',\n')}\n}` : '{}',
        suggestedKeysJson: hardcodedTexts.length > 0 ? 
            `{\n${hardcodedTexts.map(item => {
                const cleanText = item.text.replace(/[^\w\u0590-\u05FF\s]/g, '').trim();
                const keyName = cleanText.toLowerCase()
                    .replace(/\s+/g, '_')
                    .replace(/[^\w\u0590-\u05FF_]/g, '')
                    .substring(0, 50);
                return `"${keyName}": "${item.text}"`;
            }).join(',\n')}\n}` : '{}'
    };
    
    // ×¤×•× ×§×¦×™×•×ª ×¢×–×¨
    window.highlightFailedTranslations = function() {
        missingTranslations.forEach(item => {
            try {
                const element = document.evaluate(item.xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                if (element) {
                    element.style.backgroundColor = 'red';
                    element.style.color = 'white';
                    element.style.border = '2px solid darkred';
                    element.title = `×ª×¨×’×•× × ×›×©×œ: ${item.text}`;
                }
            } catch (e) {
                console.log('×œ× × ×™×ª×Ÿ ×œ×¡××Ÿ ××ª ×”××œ×× ×˜:', item.text);
            }
        });
        console.log('ğŸ”´ ×ª×¨×’×•××™× ×©× ×›×©×œ×• ×¡×•×× ×• ×‘××“×•×');
    };
    
    window.highlightHardcodedTexts = function() {
        hardcodedTexts.forEach(item => {
            try {
                const element = document.evaluate(item.xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                if (element) {
                    element.style.backgroundColor = 'yellow';
                    element.style.border = '2px solid orange';
                    element.title = `×˜×§×¡×˜ ×§×©×™×—: ${item.text}`;
                }
            } catch (e) {
                console.log('×œ× × ×™×ª×Ÿ ×œ×¡××Ÿ ××ª ×”××œ×× ×˜:', item.text);
            }
        });
        console.log('ğŸŸ¡ ×˜×§×¡×˜×™× ×§×©×™×—×™× ×¡×•×× ×• ×‘×¦×”×•×‘');
    };
    
    window.clearTranslationHighlight = function() {
        const highlighted = document.querySelectorAll('[style*="background-color: red"], [style*="background-color: yellow"]');
        highlighted.forEach(el => {
            el.style.backgroundColor = '';
            el.style.color = '';
            el.style.border = '';
            el.title = '';
        });
        console.log('ğŸ§¹ ×”×¡×™××•×Ÿ ×”×•×¡×¨');
    };
    
    console.log('\nğŸ› ï¸ ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ ×–××™× ×•×ª:');
    console.log('- highlightFailedTranslations() - ×¡××Ÿ ×ª×¨×’×•××™× ×©× ×›×©×œ×• ×‘××“×•×');
    console.log('- highlightHardcodedTexts() - ×¡××Ÿ ×˜×§×¡×˜×™× ×§×©×™×—×™× ×‘×¦×”×•×‘');
    console.log('- clearTranslationHighlight() - ×”×¡×¨ ×¡×™××•×Ÿ');
    console.log('- copy(window.masuTranslationAnalysis.failedKeysJson) - ×”×¢×ª×§ keys ×©× ×›×©×œ×•');
    console.log('- copy(window.masuTranslationAnalysis.suggestedKeysJson) - ×”×¢×ª×§ ×”×¦×¢×•×ª ×œkeys');
    console.log('- window.getMissingTranslations() - ×”×¤×¢×œ ××ª ×¤×•× ×§×¦×™×™×ª ×”××¢×¨×›×ª');
    
    return window.masuTranslationAnalysis;
})();


